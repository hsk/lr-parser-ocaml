# パーサジェネレータ

このディレクトリにはパーサジェネレータのコードが有ります。
正確に言うと、構文解析表を生成します。

## ファイル構成

ファイル構成をトップダウン的に見ると以下のようになります:

- parsergenerator.ml パーサジェネレータメイン
    - utils.ml MapとSetのユーティリティ
    - grammardb.ml 基本的な情報を作成
        - symboldiscriminator.ml 終端、非終端記号の判定
        - firstset.ml ファースト集合の生成
            - nullableset.ml Null集合の生成
    - dfagenerator.ml DFAジェネレータ
        - closureitem.ml LRアイテム
        - closureset.ml LRアイテムの集合
    - lalr1dfa.ml LALR1DFAジェネレータ
- README.md このファイル

## 大まかな処理の流れ

パーサジェネレータは、言語の文法と開始記号を受け取ってまず、grammarDBを生成します。
grammerDBの中身は文法定義、開始記号と終端、非終端記号、ファースト集合、idとルールの写像です。
ファースト集合の生成にはNull集合を使います。
grammarDBが出来たら次に、LR1のDFAを作ります。DFAの要素はLRアイテムとその集合LRアイテム集合です。
LR1のDFAが出来たら、LR1のDFAを圧縮してLALR1のDFAを作ります。
最後にLALR1のDFAから構文解析表を作ります。LALR1の構文解析表の生成に失敗したらLR1のDFAから構文解析表を作ります。

## ボトムアップ的眺め

最初からボトムアップで見るとかなり大きなものなので苦しく感じるかもしれないのでトップダウン的な見方も必要なので最初にトップダウン的に眺めてみましたが、実際に作ることを考えればボトムアップ的に見ていくと良いでしょう。

- utils.ml MapとSetのユーティリティ
- symboldiscriminator.ml 終端、非終端記号の判定
- nullableset.ml Null集合の生成
- firstset.ml ファースト集合の生成
- grammardb.ml 基本的な情報を作成
- closureitem.ml LRアイテム
- closureset.ml LRアイテムの集合
- dfagenerator.ml DFAジェネレータ
- lalr1dfa.ml LALR1DFAジェネレータ
- parsergenerator.ml パーサジェネレータメイン

要するにMakefileのコンパイル順に作ることになるので細かく見るなら作る順番でみるとボトムアップに見ることになるわけです。

## 各処理の詳細

### utils.ml MapとSetのライブラリ読み込み

集合と写像のモジュールがあるだけです。Sが文字列の集合、Mが文字列からのマップ、MIが整数からのマップです。
マップにはfold_left機能を追加してあります。

### symboldiscriminator.ml 終端、非終端記号の判定

まず最初にやることは文法定義から記号を全部取り出して、文法の左辺にある記号は非終端記号として、非終端記号ではない記号を終端記号として集合を作り、今後は関数を呼び出すことで判定できるようにします。

### nullableset.ml Null集合の生成

文法要素の状態遷移表を作るには次に何が来るかを知りたい。それがファースト集合です。
そのファースト集合を作るためには空になる可能性がある文法名を知りたい。それがNULL集合です。
文法の要素の中身が `/*empty*/` な文法要素をまず集めて、さらに、その文法要素だけを呼び出している文法要素も加えます。

以下のような文法があった場合aは明らかに空になり得ます:

```
a ->
a -> c
b -> a a a
b -> c
c -> id
```

さらに、bはaしか呼び出していないパターンがあるので空になり得るのでNULL集合に加えます。

### firstset.ml ファースト集合の生成

ファースト集合は文法が現れたら次に来る記号が何かを集めたものなので、文法名から記号の集合への写像になります。

①まず初期化を行います。EOFが来たら終わりなのでEOFを追加し、
終端記号は最初に現れるので追加し、
非終端記号は（そもそも文法名ではないのですが、チェックするときに参照されるので）空にして追加します。

②次に、文法要素でループして、次に最初に来る可能性がある記号は、空にならなくなるまでの記号なのでそれを文法名と記号のリストにして集め制約と呼びます。

③最後に集めた制約でループして、文法に対するファースト集合を取り出し、制約の記号のファースト集合を追加します。
変更があれば、制約の追加が新たに必要になる可能性があるので、なくなるまで繰り返します。

### grammardb.ml 基本的な情報を作成

文法を受取り、終端記号、非終端記号を作り、ファースト集合を作ったあと、記号と文法にIDをつけるマップを2つ作ります。

記号へのIDは0がEOF,1が開始記号,2以降が終端記号、非終端記号と続きます。
文法のIDは文法名からIDとルールの配列の写像を作ります。これは、クロージャ集合を生成する場合に使います。

### closureitem.ml LRアイテム

DFAの要素がclosureitemです。

```
S -> A B
A -> Num
B -> ;
B -> $
```

以上のような文法が合った時に、読み込み状態を `.` で表し、そこで現れる次の記号列を`[]`で括って表すと

```
S -> . A B [Num]
S -> A . B [;,$]
S -> A B . []
A -> . Num [Num]
A -> Num . []
B -> . ; [;]
B -> ; . []
B -> . $ [$]
B -> $ . []
```

のように書くことが出来ます。`S -> . A B [Num]` のような各要素をLRアイテムといいます。
空間効率をや使いやすさを考えて文法IDと `.` の位置dot_index、そこで呼ばれるであろう記号列をソートして保持し、lr0とlr1用の同値判定をやりやすくするためにハッシュも生成して保持します。

```
type closureItem = {
  rule_id: int; dot_index: int; lookaheads: token array; (* 規則id・ドット位置・先読記号集合 *)
  lr0_hash: string; lr1_hash: string                     (* LR(0)、LR(1)アイテムのハッシュ値 *)
}
```

実際の定義は以上のようになります。

### closureset.ml LRアイテムの集合

DFAの要素のLRアイテムを集めたものがLRアイテム集合closuresetです。
アイテム集合を生成するにはアイテム集合を受け取って展開したあと、アイテムと同様にハッシュを生成します。
はて、アイテム集合を生成するのにアイテム集合が必要なら最初のアイテム集合はどうなるのでしょう？
というと、開始記号アイテムのみの集合を種にします。

```
  genClosureSet db [|genClosureItem db (-1) 0 [|"EOF"|]|]
```

展開処理は、以下の③つの処理を行います：

- ①アイテム集合内のアイテムをlookaheadsごとに分解してフラットにする
- ②クロージャ展開を配列にアイテムを追加しながら追加がなくなるまで繰り返す
- ③マージする

詳細はソースを見てください。

http://tatamo.81.la/blog/2017/03/22/lr-parser-generator-implementation-04/ から引用しておきます。

> #### クロージャー展開
> 
> まず、初期化時点で存在するこのDFAノードは、まだ完全な状態にはなっていません。
> 一定のルールに従い、アイテム集合を「クロージャー展開」する必要があります。
> 
> ```nohighlight
> X -> α . Y β [x]
> X,Yは非終端記号(X=Yであってもよい)
> xは終端記号
> α,βは任意の長さの終端記号または非終端記号の列
> ```
> 
> というLRアイテムが存在する場合、`Y`を左辺として`.`が右辺の左端にあるような新しいLRアイテムを、アイテムセットに追加します。
> ただし、先読み記号はFirst(βx)で得られる記号全てとします。
> つまり、
> 
> ```nohighlight
> Y -> γ
> γは任意の長さの終端記号または非終端記号の列
> ```
> 
> というような規則があった場合、
> 
> ```nohighlight
> Y -> . γ [First(βx)]
> ```
> 
> というLRアイテムを新しく追加します。
> 
> これを、新しいアイテムが追加されなくなるまで繰り返します。

うう、だめだ。一体何を言っているのかわからねぇ。

> 具体的に見て行きましょう。
> 以下の規則を仮定します。
> 
> ```nohighlight
> S -> 0
> S -> X 1
> X -> 0
> Sは開始記号
> S,Xは非終端記号
> 0,1は終端記号
> ```
> 
> この場合、開始記号は`S`なので、最初のLRアイテムは以下のようになります。
> 
> ```nohighlight
> S' -> . S [$]
> ```
> 
> `.`の次にある`S`を展開します。
> 先読み記号は`First($)=[$]`です。
> 以下のアイテムを追加します。
> 
> ```nohighlight
> S -> . 0 [$]
> S -> . X 1 [$]
> ```
> 
> さらに、新しく追加されたアイテムにも同様の処理を行うと、`.`の次に`X`があるため、これを展開します。
> `0`は終端記号のため、展開は行いません。
> 先読み記号は、`First(1$)=[1]`です(First関数は終端記号の列の左端の記号を得るので、ここでは`1`のみとなります)。
> 
> ```nohighlight
> X -> . 0 [1]
> ```
> 
> 上の規則では`0`は終端記号のため、ここで展開は終了します。
> 
> 結果として、最初のDFAノードの持つアイテム集合は以下のようになります。
> 
> ```nohighlight
> S' -> . S [$]
> S -> . 0 [$]
> S -> . X 1 [$]
> X -> . 0 [1]
> ```
> 
> 以上がクロージャー展開の処理です。
> こうして展開したアイテム集合をもとに、新しいDFAノードを生成していきます。

だそうです。

> ClosureItemは本来複数の先読み記号を保持することができるのですが、クロージャー展開の初期化段階では、まずそれを分解し、一つのClosureItemが必ず一つの先読み記号のみを持つようにします。
> 
> この制約がなければ、たとえば[x,y]という先読み記号を持ったAというClosureItemの展開処理が済んだあと、BというClosureItemを展開したところ、[y,z]という先読み記号を持ち、先読み部分以外はAと全く同じClosureItemが生成される、といった自体が発生する可能性があります。 この場合、先読み記号yについては2度展開されてしまったり、それを防ぐために処理済みのClosureItemの走査を行うことで余計な計算が必要になってしまうなど、様々な弊害が発生します。 クロージャー展開の処理中だけはClosureItemの先読み記号は常に一つであるという制約を設けてることで、展開処理が非常に簡潔になります。
> 
> 処理が終わった段階で、ClosureItemの先読み部分をマージすることによってクロージャー展開後のClosureSetが完成します。

### dfagenerator.ml DFAジェネレータ

DFA は、node の配列として表現します。
node は、一つの closureSet と edge を持ちます。
edge はトークンをキーとして node のインデックスを持つ Map であり、これはトークンをラベルとして他の node に向けて張られた辺の情報を意味します。

DFAの生成はgenerateLR1DFAで行い

- ① EOFから生成したアイテム集合を元にDFAを生成する
- ② DFA更新処理が更新がなくなるまで続けます。


DFA更新処理はupdateDFAで行い

- ① .を進めたfollow_labelからアイテム集合へのマップを生成し
- ② 既存のNodeのなかに同一のアイテム集合を持つindexを検索してなければDFAを拡張
- ③ 検索したindexに辺が含まれていなければfollow_labelからindexから追加します

よく分かってないので、http://tatamo.81.la/blog/2017/03/22/lr-parser-generator-implementation-04/ から引用しておきます。

> #### 新しいDFAノードの生成
> 
> クロージャー展開が完了したアイテム集合から、一定のルールのもとで新しいDFAノードを生成します。
> 
> ```nohighlight
> X -> α . A β [x]
> Xは非終端記号
> Aは終端記号または非終端記号(X=Aであってもよい)
> xは終端記号
> α,βは任意の長さの終端記号または非終端記号の列
> ```
> 
> というLRアイテムが存在する場合、以下の新しいLRアイテムを生成します(そのDFAノードのアイテムセットには追加しません)。
> 
> ```nohighlight
> X -> α A . β [x]
> ```
> 
> そのDFAノードの持つ全てのLRアイテムについてこの処理が終わったら、`.`の左隣の記号、つまり`A`の位置の記号ごとに新しいアイテム集合を作り、それを情報としてもつ新しいDFAノードを生成します。
> そして既存のDFAノードから、`A`をラベルとして新しいノードに対して辺を張ります。
> あとは、新しいノード全てについて、同様にクロージャー展開を行い、さらに新しいDFAノードを生成していきます。
> ただし、その過程で既存のノードと全く同じアイテム集合を持つDFAノードが作られた場合は、新しいノードとしてそこに辺を張るのではなく、かわりに重複する既存のノードに対して辺を張るものとします。
> 
> この処理を繰り返し、DFAノードが新しく生成されなくなればDFAの構築は終了です。

これもよくわからないんだなぁ。

> 具体的には、
> 
> ```nohighlight
> S' -> . S [$]
> S -> . 0 [$]
> S -> . X 1 [$]
> X -> . 0 [1]
> ```
> 
> というアイテム集合を持つDFAからは、
> 
> ```nohighlight
> S' -> S . [$]
> S -> 0 . [$]
> S -> X . 1 [$]
> X -> 0 . [1]
> ```
> 
> という4つのLRアイテムが生成され、これは以下の3つに分けられます。
> 
> ```nohighlight
> 1. ラベル: S
> S' -> S . [$]
> ```
> 
> ```nohighlight
> 2. ラベル: 0
> S -> 0 . [$]
> X -> 0 . [1]
> ```
> 
> ```nohighlight
> 3. ラベル: X
> S -> X . 1 [$]
> ```
> 
> このようにして新しく3つのDFAノードを生成し、もとのノードからそれぞれの記号をラベルとした辺を張ります。

ということを理解すればいいようです。

### lalr1dfa.ml LALR1DFAジェネレータ

generateLALR1DFAでLR1のDFAを圧縮したLALR1のDFAを生成します。

生成処理は以下の3つのパートが有ります:

- ① 配列を2重ループでマージしながら削除履歴を残します。
- ② 削除履歴から削除部分のないDFAを作成しつつ古いindexから新しいindexへの写像を作ります。
- ③ エッジ内のインデックスを古いindexから新しいindexへ書き換えます。

### parsergenerator.ml パーサジェネレータメイン

大まかな流れはすでに説明しましたが、DFAから構文解析表を作る説明はまだですので説明します。

構文解析表の生成はDFAのノードから構文解析表の要素へマップしたものです。
ノードの辺のラベルが終端記号ならshiftと非終端ならgotoオペレーションを追加できます。

ノードのClosureをもとにitemのルールがEOFならacceptを追加でき、それ以外ならreduceオペレーションを追加できます。
追加する際にすでに追加されていた場合コンフリクトが発生していることになります。
