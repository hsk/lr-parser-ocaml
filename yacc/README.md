# パーサジェネレータ

このディレクトリにはパーサジェネレータのコードが有ります。
正確に言うと、構文解析表を生成します。

## ファイル構成

ファイル構成をトップダウン的に見ると以下のようになります:

- parsergenerator.ml パーサジェネレータメイン
    - utils.ml MapとSetのユーティリティ
    - grammardb.ml 基本的な情報を作成
        - symboldiscriminator.ml 終端、非終端記号の判定
        - firstset.ml ファースト集合の生成
            - nullableset.ml Null集合の生成
    - dfagenerator.ml DFAジェネレータ
        - closureitem.ml LRアイテム
        - closureset.ml LRアイテムの集合
- README.md このファイル

## 大まかな処理の流れ

パーサジェネレータは、言語の文法と開始記号を受け取ってまず、grammarDBを生成します。
grammerDBの中身は文法定義、開始記号と終端、非終端記号、ファースト集合、idとルールの写像です。
ファースト集合の生成にはNull集合を使います。
grammarDBが出来たら次に、LR1のDFAを作ります。DFAの要素はLRアイテムとその集合LRアイテム集合です。
LR1のDFAが出来たら、LR1のDFAを圧縮してLALR1のDFAを作ります。
最後にLALR1のDFAから構文解析表を作ります。LALR1の構文解析表の生成に失敗したらLR1のDFAから構文解析表を作ります。

## ボトムアップ的眺め

最初からボトムアップで見るとかなり大きなものなので苦しく感じるかもしれないのでトップダウン的な見方も必要なので最初にトップダウン的に眺めてみましたが、実際に作ることを考えればボトムアップ的に見ていくと良いでしょう。

- utils.ml MapとSetのユーティリティ
- symboldiscriminator.ml 終端、非終端記号の判定
- nullableset.ml Null集合の生成
- firstset.ml ファースト集合の生成
- grammardb.ml 基本的な情報を作成
- closureitem.ml LRアイテム
- closureset.ml LRアイテムの集合
- dfagenerator.ml DFAジェネレータ
- parsergenerator.ml パーサジェネレータメイン

要するにMakefileのコンパイル順に作ることになるので細かく見るなら作る順番でみるとボトムアップに見ることになるわけです。

## 各処理の詳細

### utils.ml MapとSetのライブラリ読み込み

集合と写像のモジュールがあるだけです。Sが文字列の集合、Mが文字列からのマップ、MIが整数からのマップです。
マップにはfold_left機能を追加してあります。

### symboldiscriminator.ml 終端、非終端記号の判定

まず最初にやることは文法定義から記号を全部取り出して、文法の左辺にある記号は非終端記号として、非終端記号ではない記号を終端記号として集合を作り、今後は関数を呼び出すことで判定できるようにします。

### nullableset.ml Null集合の生成

文法要素の状態遷移表を作るには次に何が来るかを知りたい。それがファースト集合です。
そのファースト集合を作るためには空になる可能性がある文法名を知りたい。それがNULL集合です。
文法の要素の中身が `/*empty*/` な文法要素をまず集めて、さらに、その文法要素だけを呼び出している文法要素も加えます。

以下のような文法があった場合aは明らかに空になり得ます:

```
a ->
a -> c
b -> a a a
b -> c
c -> id
```

さらに、bはaしか呼び出していないパターンがあるので空になり得るのでNULL集合に加えます。

### firstset.ml ファースト集合の生成

ファースト集合は文法が現れたら次に来る記号が何かを集めたものなので、文法名から記号の集合への写像になります。
まず初期化を行います。EOFが来たら終わりなのでEOFを追加し、
終端記号は最初に現れるので追加し、
非終端記号はそもそも文法要素として呼び出されないのですが、チェックするときに参照されるので空にして追加します。

次に、文法要素でループして、次に最初に来る可能性がある記号は、空にならなくなるまでの記号なのでそれを文法名と記号のリストにして集め制約と呼ぶことにします。
最後に集めた制約でループして、文法に対するファースト集合を取り出し、制約の記号のファースト集合を追加します。
変更があれば、制約の追加が新たに必要になる可能性があるので、なくなるまで繰り返します。

### grammardb.ml 基本的な情報を作成

文法を受取り、終端記号、非終端記号を作り、ファースト集合を作ったあと、記号と文法にIDをつけるマップを2つ作ります。
記号へのIDは0がEOF,1が開始記号,2以降が終端記号、非終端記号と続きます。
文法のIDは文法名からIDとルールの配列の写像を作ります。これは、クロージャ集合を生成する場合に使います。

### closureitem.ml LRアイテム

DFAの要素がclosureitemです。

```
S -> A B
A -> Num
B -> ;
B -> $
```

以上のような文法が合った時に、読み込み状態を `.` で表し、そこで現れる次の記号列を`[]`で括って表すと

```
S -> . A B [Num]
S -> A . B [;,$]
S -> A B . []
A -> . Num [Num]
A -> Num . []
B -> . ; [;]
B -> ; . []
B -> . $ [$]
B -> $ . []
```

のように書くことが出来ます。`S -> . A B [Num]` のような各要素をLRアイテムといいます。
空間効率をや使いやすさを考えて文法IDと `.` の位置dot_index、そこで呼ばれるであろう記号列をソートして保持し、lr0とlr1用の同値判定をやりやすくするためにハッシュも生成して保持します。

```
type closureItem = {
  rule_id: int; dot_index: int; lookaheads: token array; (* 規則id・ドット位置・先読記号集合 *)
  lr0_hash: string; lr1_hash: string                     (* LR(0)、LR(1)アイテムのハッシュ値 *)
}
```

実際の定義は以上のようになります。

### closureset.ml LRアイテムの集合

DFAの要素のLRアイテムを集めたものがLRアイテム集合closuresetです。
アイテム集合を生成するにはアイテム集合を受け取って展開したあと、アイテムと同様にハッシュを生成します。
はて、アイテム集合を生成するのにアイテム集合が必要なら最初のアイテム集合はどうなるのでしょう？
というと、開始記号アイテムのみの集合を種にします。

```
  let ci = genClosureItem db (-1) 0 [|"EOF"|] in
  let cs = genClosureSet db [|ci|] in
```

展開処理は、以下の③つの処理を行います：

- ①最初にClosureItemをlookaheadsごとに分解する。
- ②各要素を更に展開しアイテム追加しながら変更がなくなるまで繰り返す
- ③マージする

おそらくこのあたりが一番複雑です。詳細はソースを見てください。

### dfagenerator.ml DFAジェネレータ

DFAの生成もclosuresetのような感じで生成できます。
これもまた複雑です。詳細はソースを見てください。

generateLR1DFA でLR1のDFAを生成し、generateLALR1DFAでLR1のDFAを圧縮したLALR1のDFAを生成します。

### parsergenerator.ml パーサジェネレータメイン

大まかな流れはすでに説明しましたが、DFAから構文解析表を作る説明はまだですので説明します。

構文解析表の生成はDFAのノードから構文解析表の要素へマップしたものです。
ノードの辺のラベルが終端記号ならshiftと非終端ならgotoオペレーションを追加できます。

ノードのClosureをもとにitemのルールがEOFならacceptを追加でき、それ以外ならreduceオペレーションを追加できます。
追加する際にすでに追加されていた場合コンフリクトが発生していることになります。
